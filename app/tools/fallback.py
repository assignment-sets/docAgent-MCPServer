from app.dependencies import get_gemini_llm
from app.schemas import FallbackInput, PyRuntimeInput
from app.tools import exec_py_runtime

from langchain_core.messages import SystemMessage, HumanMessage
from langchain_core.runnables import Runnable

import logging

logger = logging.getLogger(__name__)


async def fallback_tool(input: FallbackInput) -> str:
    try:
        logger.info("[üß†] Fallback tool invoked with prompt:\n%s", input.prompt)

        llm = get_gemini_llm()

        system_prompt = SystemMessage(
            content="""
You are a Python coding assistant. Produce a single valid Python script that accomplishes the user's natural-language task using ONLY Python and only the installed packages: numpy, pandas, matplotlib, seaborn, scipy, sympy, scikit-learn, requests.

Environment:
- Runs in a sandboxed Python runtime with network access.
- A watcher auto-uploads any NEW files created in the CURRENT WORKING DIRECTORY and returns temporary public URLs. DO NOT upload files or attempt to generate URLs.
- Use only the listed dependencies. If the task requires an unavailable package, print the reason (using print()) and exit ‚Äî do not create files.

Constraints:
- No GUI available.
- DO NOT print results to stdout (except the "cannot solve" message above).
- Write outputs to files in the CURRENT WORKING DIRECTORY (no subdirectories).
- Generate Python code only. If you cannot solve the task under these constraints, print the reason and exit without writing files.

""".strip()
        )

        # Construct the full message sequence
        messages = [system_prompt, HumanMessage(content=input.prompt)]

        # Bind the LLM to output PyRuntimeInput format
        structured_llm: Runnable = llm.with_structured_output(PyRuntimeInput)

        # Call the LLM
        output: PyRuntimeInput = await structured_llm.ainvoke(messages)
        # print(output)

        logger.info("[‚úÖ] Code successfully generated by fallback LLM.")
        logger.info(output)

        # Execute the generated Python code using the py_runtime tool
        result = await exec_py_runtime(output)

        return result

    except Exception as e:
        logger.exception("[‚ùå] Fallback tool execution failed.")
        return f"Fallback failed: {str(e)}"


if __name__ == "__main__":
    import asyncio

    ip = FallbackInput(
        prompt="Can you please put the text '\\u09b9\\u09cd\\u09af\\u09be\\u09b2\\u09cb, \\u0986\\u09ae\\u09bf \\u098f\\u0995\\u09be\\u0987 \\u09b8\\u09ae\\u09cd\\u09ae\\u09be\\u09a8\\u09bf\\u09a4\\u0964' into a text file? "
    )

    async def test_fallback():
        op = await fallback_tool(ip)
        print(f"op: {op}")

    asyncio.run(test_fallback())
